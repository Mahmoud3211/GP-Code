<head>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"> </script>
    <script src="loadModel.js"> </script>
    <script async src="opencv.js" onload="onOpenCvReady(1);" type="text/javascript"></script>
</head>
<body>
    <div style="text-align: center;">
        <label for="classReader">Select Classes File</label>
        <input type="file" accept=".txt" id="classReader">
        <br>
        <label for="videoSelect">Select Video</label>
        <input type="file" id="videoSelect" accept="video/*">
        <br>
        <video id="videoInput" width="420" height="380" muted>
            <source src="" type="video/mp4">
            <!-- <source src="mov_bbb.ogg" type="video/ogg"> -->
                Your browser does not support HTML video.
        </video>
        <br><br>

        <button id="start" value=1 onclick="updateStreaming(this)">Start</button>

        <button id="stop" value=0 onclick="updateStreaming(this)">Stop</button>

        <button id="predict" onclick="makePrediction()">Predict</button>


    </div>
    <br>
    <div style="text-align: center;">
        <p id="predStatus">Prediction Area</p>
    </div>
    <br>
    <div class="inputoutput" style="text-align: center;" hidden>
        <canvas id="canvasOutput" ></canvas>
        <div class="caption">canvasOutput</div>
    </div>

    <script>
        let video = document.getElementById('videoInput');
        let can = document.getElementById('canvasOutput');
        let classes= [];
        let classesInput = document.getElementById('classReader').addEventListener('change', function(){
            var fr = new FileReader();
            fr.onload = function(){
                classes = fr.result.split("\n");
            }
            fr.readAsText(this.files[0]);
        })
        
        let videoSelect = document.getElementById('videoSelect').addEventListener('change', function(){
            video.src = this.files[0]['name']
        })
        

        streaming = 0
        frames = []
        const loadM = new loadModel()
        loadM.prepareModel()

        function updateStreaming(input){
            streaming = input.value
            if (streaming == 1){
                console.log('Start')
                onOpenCvReady()
            }
            else{
                console.log('Stop')
            }
        }
        function checkStreaming(){
            return streaming
        }
        async function makePrediction(){
            document.getElementById('predStatus').innerHTML = "Waiting Prediction...";
            rescaledFrames = [];
            var i;
            for (i = 0; i < 30; i++) {
                rescaledFrames.push(frames[i])
            }

            // console.log(frames[0])
            // console.log(tf.stack(rescaledFrames).shape)
            // tf.tensor(frames[0], frames[1]).print()
            // console.log(tf.tensor(frames[0], frames[1]))
            // console.log(tf.tensor(rescaledFrames).shape)
            pred = await loadM.predict(rescaledFrames)
            alert("Class Predicted is -> " + classes[pred])
            document.getElementById('predStatus').innerHTML = "Class Predicted is -> " + classes[pred];

        }
        function onOpenCvReady(firstTime = 0) {

            if(firstTime)
                alert('OpenCV.js is ready.')


            let src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
            let dst = new cv.Mat();
            let cap = new cv.VideoCapture(video);
            let dsize = new cv.Size(300, 300);


            const FPS = 30;
            function processVideo() {
                try {
                    streaming = checkStreaming()
                    if (streaming == 0) {
                        // clean and stop.
                        src.delete();
                        dst.delete();
                        video.pause()
                        return;
                    }
                    video.play()
                    let begin = Date.now();
                    // start processing.
                    cap.read(src);
                    // cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY);
                    cv.resize(src, dst, dsize, 0, 0, cv.INTER_AREA);
                    cv.imshow('canvasOutput', dst);

                    frames.push(tf.browser.fromPixels(can))
                    console.log('Length of the Video Frames -> ')
                    console.log(frames.length)
                    // if (frames.length >= 30){
                    //     clearTimeout(t)
                    // }
                    // console.log(frames)

                    // schedule the next one.
                    let delay = 1000/FPS - (Date.now() - begin);
                    t = setTimeout(processVideo, delay);

                } catch (err) {
                    console.log(err);
                }
            };

            // schedule the first one.
            t = setTimeout(processVideo, 0);
            }

    </script>
</body>
